#! /bin/sh

set -x

##### Définition des variables

IF_PROD="eno1";
IF_EXT="enp0s20u1";
NULL_IP="0.0.0.0";

##### Fonctions

function open_out_tcp_strict () {
    iptables -t filter -A OUTPUT -o $1 -s $2 -d $3   \
    -p tcp --dport $4 -m conntrack --ctstate NEW,RELATED,ESTABLISHED -j ACCEPT;

    iptables -t filter -A INPUT  -i $1 -s $3 -d $2 \
    -p tcp --sport $4 -m conntrack --ctstate     RELATED,ESTABLISHED -j ACCEPT;
}

function open_out_udp_strict () {
    iptables -t filter -A OUTPUT -o $1 -s $2 -d $3   \
    -p udp --dport $4 -m conntrack --ctstate NEW,RELATED,ESTABLISHED -j ACCEPT;

    iptables -t filter -A INPUT  -i $1 -s $3 -d $2 \
    -p udp --sport $4 -m conntrack --ctstate     RELATED,ESTABLISHED -j ACCEPT;
}

function open_out_tcp_any () {
    iptables -t filter -A OUTPUT -o $1 -s $2   \
    -p tcp --dport $3 -m conntrack --ctstate NEW,RELATED,ESTABLISHED -j ACCEPT;

    iptables -t filter -A INPUT  -i $1   -d $2 \
    -p tcp --sport $3 -m conntrack --ctstate     RELATED,ESTABLISHED -j ACCEPT;
}

function get_ip () {
    if ip link show $1 > /dev/null; then
        ip addr show $1 | grep "inet " | sed 's+.*inet \(.*\)/.*+\1+';
    else
        echo $NULL_IP;
    fi
}

function get_dns () {
    cat /etc/resolv.conf | grep nameserver | awk '{print $2}';
}

function resolv () {
    (nslookup "$1" | grep -A1 "Name:" | grep -Eo '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | tr '\n' ',') 2> /dev/null;
}

MY_IP_EXT=`get_ip $IF_EXT`;
MY_IP_PROD=`get_ip $IF_PROD`;

[[ "$MY_IP_EXT" != "$NULL_IP" ]] && MY_IP_PROD=$MY_IP_EXT && IF_PROD=$IF_EXT;

##### Nettoyage des règles existantes
iptables -F; # Flush (supression des règles)
iptables -X; # Supression des chaînes perso

##### Règles de filtrages

# Par défaut, tout est interdit : bonne pratique de sécurité
# On bloque tout silencieusement…

iptables -t filter -P INPUT DROP;
iptables -t filter -P FORWARD DROP;
iptables -t filter -P OUTPUT DROP;

# Journaliser tout ce qu'on rejette
iptables -N LOG_DROP;
iptables -A LOG_DROP -j LOG --log-prefix '[IPTABLES DROP]: ';
iptables -A LOG_DROP -j DROP;

# Éventuellement : protection contre le scan de port
# Remplacer la règle ci-dessus par :
# iptables -A LOG_DROP -j TARPIT;

# Journaliser certaines choses qu'on accepte
iptables -N LOG_ACCEPT;
iptables -A LOG_ACCEPT -j LOG --log-prefix '[IPTABLES ACCEPT]: ';
iptables -A LOG_ACCEPT -j ACCEPT;

for dns in `get_dns`; do
    iptables -t filter -A OUTPUT -o $IF_PROD -s $MY_IP_PROD -d $dns \
    -p udp -m udp --dport 53 -m conntrack --ctstate NEW,RELATED,ESTABLISHED -j ACCEPT;

    iptables -t filter -A INPUT  -i $IF_PROD -d $MY_IP_PROD -s $dns \
    -p udp -m udp --sport 53 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT;
done;

# Ports sortant ICMP
iptables -t filter -A OUTPUT -o $IF_PROD -s $MY_IP_PROD \
-p icmp --icmp-type echo-request -j LOG_ACCEPT;

iptables -t filter -A INPUT  -i $IF_PROD -d $MY_IP_PROD \
-p icmp --icmp-type echo-reply -j LOG_ACCEPT;

# Ports habituels sur le web
for tcp_port in 443 80; do
    open_out_tcp_any $IF_PROD $MY_IP_PROD $tcp_port;
done;

# Open myfirm special ports if needed
if [[ "$( (nslookup $dns | grep name | awk '{print $4}') 2> /dev/null)" == "ns2.myfirm.eu." ]]; then
    _smtp=$(resolv smtp.myfirm.eu);
    _imap=$(resolv imap.myfirm.eu);
    _xmpp=$(resolv xmpp.myfirm.eu);
    open_out_tcp_strict $IF_PROD $MY_IP_PROD ${_smtp:0:-1} 25;   # smtp interne
    open_out_tcp_strict $IF_PROD $MY_IP_PROD ${_imap:0:-1} 143;  # imap
    open_out_tcp_strict $IF_PROD $MY_IP_PROD ${_xmpp:0:-1} 5222; # imap

    _f1=$(resolv filer1.myfirm.eu);
    _f2=$(resolv filer2.myfirm.eu);
    open_out_tcp_strict $IF_PROD $MY_IP_PROD ${_f1}${_f2:0:-1} 445; # tcp smb
    open_out_udp_strict $IF_PROD $MY_IP_PROD ${_f1}${_f2:0:-1} 445; # udp smb

fi

# Open external usage
open_out_tcp_strict $IF_PROD $MY_IP_PROD 192.30.252.0/22 ssh; #github

_off365=$(resolv outlook.office365.com); ##### Office365 IMAP, SMTP
open_out_tcp_strict $IF_PROD $MY_IP_PROD ${_off365:0:-1} 587;
open_out_tcp_strict $IF_PROD $MY_IP_PROD ${_off365:0:-1} 143;

# Brouillage
iptables -t filter -A INPUT -p tcp -j TARPIT;
